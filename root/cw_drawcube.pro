;+
; PURPOSE:
;  cw_drawcube is a compound widget that displays data
;  cubes. User's can view slices through the cube along each
;  dimension, and adjust the color scaling.
;
; CATEGORY:
;  Widgets
;
; CALLING SEQUENCE:
;  widget = cw_drawcube(data, parent)
;
; INPUTS:
;  data: A 3D array of image data to display
;  parent: The id of the widget_base into which this widget is to be
;          placed. If omitted, the drawcube widget will be created as
;          a top level base
;  
; KEYWORD PARAMETERS:
;  uvalue: An optional user value to attach to this widget
;
; OUTPUTS:
;  The id of the new widget
;
; SIDE EFFECTS:
;  The widget will generate new events to pass up the hierarchy, when
;  a user positions the mouse in one of the draw windows. The event
;  structure is named DRAWCUBE_EV, and has the following tags:
;   x: The x pixel corresponding to the mouse position (and slice
;      index, for the third dimension)
;   y: The y coordinate of the mouse
;   z: The z coordinate of the mouse
;   press: The press tag generated by draw widgets
;   type: The type tag generated by draw widgets
;   data: A pointer to the data cube
;
; PROCEDURE:
;  The user can adjust the slices by moving the slide bars, and can
;  adjust the color stretch by right-clicking and dragging, a la ds9.
;
;  Calling get_value on this widget returns a pointer to the data
;  cube. 
;
;  Using set_value replaces the data cube with a new, user specified
;  cube. 
;
; MODIFICATION HISTORY:
;  August 2010: Written by Chris Beaumont
;-

pro cw_drawcube_destroy, id
  widget_control, id, get_uvalue = state, /no_copy
  ptr_free, state.data
end

function cw_drawcube_get_val, id
  compile_opt idl2, hidden

  child = widget_info(id, /child)
  widget_control, child, get_uvalue = state, /no_copy
  result = state.data
  widget_control, child, set_uvalue = state, /no_copy
  return, result
end

pro cw_drawcube_set_val, id, data
  compile_opt idl2, hidden

  if n_elements(data) eq 0 || size(data, /n_dim) ne 3 then $
     message, 'input data must be a 3D array'

  child = widget_info(id, /child)
  widget_control, child, get_uvalue = state, /no_copy
  ptr_free, state.data
  state.data = ptr_new(data)
  widget_control, child, set_uvalue = state, /no_copy
end

;- 
; handles the events generated within the draw windows
;-  
function cw_drawcube_draw_event, ev, child, state
  compile_opt idl2, hidden

  ;- compute xyz position of mouse in the cube
  if ev.id eq state.xy then begin
     x = ev.x & y = ev.y & z = state.z
  endif else if ev.id eq state.yz then begin
     x = state.x & y = ev.x & z = ev.y
  endif else if ev.id eq state.xz then begin
     x = ev.x & y = state.y & z = ev.y
  endif else message, 'bug!'

  ;- are we right-clicking and dragging?
  if ev.press eq 4 then state.drag = 1B
  if ev.release eq 4 then state.drag = 0B

  ;- rescale with motion events when RMB is clicked
  if state.drag && ev.type eq 2 then begin
     
     widget_control, ev.id, get_value = wid
     wset, wid
     wx = 1. * ev.x / !d.x_size & wy = 1. * ev.y / !d.y_size
     black = state.min + wx * (state.max - state.min)
     white = black + wy * (state.max - black)

     state.black = black & state.white = white
     drawcube_update_widgets, state
  endif
  widget_control, child, set_uvalue = state, /no_copy 

  ;- pass along x,y,z click info up the hierarchy
  return, {drawcube_ev, id:ev.handler, top:ev.top, handler:0L, $
           x:x, y:y, z:z, press:ev.press, type:ev.type}
end

;- intercepts all events generated by cw_drawcube
function cw_drawcube_event, ev
  compile_opt idl2, hidden

  child = widget_info(ev.handler, /child)
  widget_control, child, get_uvalue= state, /no_copy

  drawcube_resize, ev.top, state

  ;- which widget generated the event?
  case ev.id of
     state.yz: return, cw_drawcube_draw_event(ev, child, state)
     state.xz: return, cw_drawcube_draw_event(ev, child, state)
     state.xy: return, cw_drawcube_draw_event(ev, child, state)
     state.xslide:state.x = ev.value
     state.yslide:state.y = ev.value
     state.zslide:state.z = ev.value
     else: echo, id
  endcase
  drawcube_update_widgets, state
  widget_control, child, set_uvalue = state, /no_copy

  ;-swallow the event
  return, 0
end


pro drawcube_resize, id, state
  g = widget_info(id, /geometry)
  print, g.scr_xsize, g.scr_ysize
  if g.scr_xsize eq state.scr_xsize && $
     g.scr_ysize eq state.scr_ysize then return

  gx = widget_info(state.yz, /geometry)
  widget_control, state.yz, draw_xsize = g.scr_xsize / 3.1, $
                  draw_ysize = g.scr_xsize / 3.1 * (1. * gx.scr_ysize / gx.scr_xsize)

  gy = widget_info(state.xz, /geometry)
  widget_control, state.xz, draw_xsize = g.scr_xsize / 3.1, $
                  draw_ysize = g.scr_xsize / 3.1 * (1. * gy.scr_ysize / gy.scr_xsize)

  gz = widget_info(state.xy, /geometry)
  widget_control, state.xy, draw_xsize = g.scr_xsize / 3.1, $
                  draw_ysize = g.scr_xsize / 3.1 * (1. * gz.scr_ysize / gz.scr_xsize)

  state.scr_xsize = g.scr_xsize
  state.scr_ysize = g.scr_ysize
end

                  


pro drawcube_update_widgets, state, mask = mask, _extra = extra
  compile_opt idl2, hidden

  ;- make sure that sliders are on correct value
  widget_control, state.xslide, set_value = state.x
  widget_control, state.yslide, set_value = state.y
  widget_control, state.zslide, set_value = state.z
  
  ;- display the requested slices, with the requested 
  ;- color stretches
  widget_control, state.xy, get_value = wid
  wset, wid
  plane = (*state.data)[*, *, state.z]
  denom = (state.white - state.black) > 1
  tvimage, byte(0 > ((plane - state.black) * 255 / denom) < 255), $
           pos = p
  if keyword_set(mask) then begin
     plane = reform(mask[*,*,state.z])
     contour, plane eq -1, xsty = 5, ysty = 5, $
              /noerase, pos = p, color = fsc_color('red')
     contour, plane eq 1, /over, color = fsc_color('green')
  endif

  widget_control, state.yz, get_value = wid
  wset, wid
  plane = (*state.data)[state.x, *, *]
  tvimage, byte(0 > ((plane - state.black) * 255 / denom) < 255)
  if keyword_set(mask) then begin
     plane = reform(mask[state.x,*,*])
     contour, plane eq - 1, xsty = 5, ysty = 5, $
              /noerase, pos = p, color = fsc_color('red')
     contour, plane eq 1, /over, color = fsc_color('green')
  endif

  widget_control, state.xz, get_value = wid
  wset, wid
  plane = (*state.data)[*, state.y, *]
  tvimage, byte(0 > ((plane - state.black) * 255 / denom) < 255)
  if keyword_set(mask) then begin
     plane = reform(mask[*,state.y,*])
     contour, plane eq - 1, xsty = 5, ysty = 5, $
              /noerase, pos = p, color = fsc_color('red')
     contour, plane eq 1, /over, color = fsc_color('green')
  endif

end


function cw_drawcube, data, parent, uvalue = uvalue
  compile_opt idl2

  hasParent = n_elements(parent) ne 0

  if n_elements(data) eq 0 || size(data, /n_dim) ne 3 then $
     message, 'input must be a 3D array'
  
  sz = size(data)
  black = min(data, /nan, max = white)

  ;- the draw widgets
  if hasParent then $
     tlb = widget_base(parent, row=1, func_get_value='cw_drawcube_get_val', $
                       pro_set_value='cw_drawcube_set_val', event_func='cw_drawcube_event', $
                       uvalue = uvalue) $
  else $
     tlb = widget_base(row=1, func_get_value='cw_drawcube_get_val', $
                       pro_set_value='cw_drawcube_set_val', event_func='cw_drawcube_event', $
                       uvalue = uvalue) 

  c1 = widget_base(tlb, col=1)
  c2 = widget_base(tlb, col=1)
  c3 = widget_base(tlb, col=1)
  yzd = widget_draw(c1, xsize = sz[2], ysize = sz[3], $
                    uvalue = 'yz', /button_e, /motion)
  xzd = widget_draw(c2, xsize = sz[1], ysize = sz[3], $
                    uvalue = 'xz', /button_e, /motion)                    
  xyd = widget_draw(c3, xsize = sz[1], ysize = sz[2], $
                    uvalue = 'xy', /button_e, /motion)

  ;- the plane slider widgets
  x = sz[1]/2 & y = sz[2]/2 & z = sz[3]/2
  xlab = widget_label(c1, value = 'X plane')
  ylab = widget_label(c2, value = 'Y plane')
  zlab = widget_label(c3, value = 'Z plane')

  xslide = widget_slider(c1, min = 0, max = sz[1]-1, $
                        uval = 'xslide', val = z, /drag)
  yslide = widget_slider(c2, min = 0, max = sz[2]-1, $
                        uval = 'yslide', val = y, /drag)
  zslide = widget_slider(c3, min = 0, max = sz[3]-1, $
                        uval = 'zslide', val = z, /drag)
  
  ;- state information
  state = { x: x, y: y, z: z, data: ptr_new(data), $
            xslide: xslide, yslide: yslide, zslide: zslide, $
            xz: xzd, yz: yzd, xy: xyd, $
            black: black, white: white, $
            min: black, max:white, drag: 0B, $
            scr_xsize:0, scr_ysize:0}

  child = widget_info(tlb, /child)
  widget_control, child, kill_notify='cw_drawcube_destroy'
  widget_control, child, set_uvalue = state, /no_copy

  return, tlb
end

pro test_event, ev
  compile_opt idl2, hidden
;  help, ev
end

pro test
  compile_opt idl2, hidden

  data = fltarr(256, 256, 256)
  indices, data, x, y, z
  x -= 128 & y -= 128 & z -= 128
  data = sin(sqrt(x^2 + y^2 +z^2) / 30)

  data = mrdfits('~/m17loop/mosaic.fits',0,h)
  nanswap, data, 0
  sz = size(data)
  mask = reform(data[*,*,50])
  mask = erode(mask ne 0, replicate(1B, 15, 15))
  data *= rebin(mask, sz[1], sz[2], sz[3])

  tlb = widget_base()
  draw = cw_drawcube(data, tlb)

  widget_control, tlb, /realize
  xmanager, 'test', tlb, event_handler='test_event'
end
  
